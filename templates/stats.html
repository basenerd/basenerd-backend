{% extends "base.html" %}
{% block content %}

<div class="card">
  <div class="card-header">
    <div>
      <div class="card-title">Stats</div>
      <div class="card-subtitle">League leaderboards • filter, sort, paginate</div>
    </div>
  </div>

  <div class="card-body">
    <div class="stats-controls">
      <select id="group" class="select">
        <option value="batting" {{ 'selected' if group=='batting' else '' }}>Batting</option>
        <option value="pitching" {{ 'selected' if group=='pitching' else '' }}>Pitching</option>
        <option value="fielding" {{ 'selected' if group=='fielding' else '' }}>Fielding</option>
        <option value="baserunning" {{ 'selected' if group=='baserunning' else '' }}>Baserunning</option>
      </select>

      <select id="season" class="select">
        {# simple season list: current back 25 years #}
        {% set start = season %}
        {% for y in range(start, start-26, -1) %}
          <option value="{{ y }}" {{ 'selected' if y==season else '' }}>{{ y }}</option>
        {% endfor %}
      </select>

      <select id="league_id" class="select">
        {% for lg in leagues %}
          <option value="{{ lg.id }}">{{ lg.label }}</option>
        {% endfor %}
      </select>

      <select id="team_id" class="select">
        <option value="">All Teams</option>
        {% for t in teams %}
          <option value="{{ t.id }}">{{ t.name }}</option>
        {% endfor %}
      </select>

      <select id="position" class="select">
        <option value="">All Positions</option>
        {% for p in positions %}
          {% if p %}
            <option value="{{ p }}">{{ p }}</option>
          {% endif %}
        {% endfor %}
      </select>

      <select id="pool" class="select">
        <option value="ALL">All Players</option>
        <option value="QUALIFIED" selected>Qualified Only</option>
      </select>

      <select id="sort" class="select"></select>

      <button id="toggleOrder" class="btn" data-order="desc">DESC</button>
      <button id="apply" class="btn">Apply</button>
    </div>

    <hr style="margin:12px 0;"/>

    <div class="table-wrap">
      <table class="table stats-table">
        <thead id="thead"></thead>
        <tbody id="tbody">
          <tr><td class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <div class="pager">
      <button id="prev" class="btn">Prev</button>
      <button id="next" class="btn">Next</button>
      <span id="range" class="range-pill">—</span>
      <span class="muted" id="pageLabel"></span>
    </div>

    <div class="pager" id="pageButtons"></div>
  </div>
</div>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const sortOptions = {
    batting: [
      ["ops","OPS"],["avg","AVG"],["obp","OBP"],["slg","SLG"],
      ["homeRuns","HR"],["rbi","RBI"],["hits","H"],["runs","R"],["stolenBases","SB"]
    ],
    pitching: [
      ["era","ERA"],["whip","WHIP"],["strikeOuts","SO"],["wins","W"],
      ["saves","SV"],["inningsPitched","IP"],["baseOnBalls","BB"],["hits","H"]
    ],
    fielding: [
      ["fielding","Fld%"],["assists","A"],["putOuts","PO"],["errors","E"],
      ["doublePlays","DP"]
    ],
    baserunning: [
      ["stolenBases","SB"],["caughtStealing","CS"],["stolenBasePercentage","SB%"],
      ["runs","R"]
    ]
  };

  // Defaults per group (used on reset + first load)
  const defaultSort = {
    batting: "ops",
    pitching: "era",
    fielding: "fielding",
    baserunning: "stolenBases"
  };

  function fillSortOptions(group){
    const s = el("sort");
    s.innerHTML = "";
    (sortOptions[group] || sortOptions.batting).forEach(([v,label])=>{
      const o = document.createElement("option");
      o.value = v;
      o.textContent = label;
      s.appendChild(o);
    });
    s.value = defaultSort[group] || "ops";
  }

  function queryParams(page){
    const group = el("group").value;
    const season = el("season").value;
    const league_id = el("league_id").value;
    const team_id = el("team_id").value;
    const position = el("position").value;
    const pool = el("pool").value;
    const sort = el("sort").value;
    const order = el("toggleOrder").dataset.order || "desc";

    const p = new URLSearchParams();
    p.set("group", group);
    p.set("season", season);
    if (league_id) p.set("league_id", league_id);
    if (team_id) p.set("team_id", team_id);
    if (position) p.set("position", position);
    p.set("pool", pool);
    p.set("sort", sort);
    p.set("order", order);
    p.set("page", String(page || 1));
    return p.toString();
  }

  function columnsFor(group){
    if (group === "pitching"){
      return [
        ["wins","W"],["losses","L"],["era","ERA"],["whip","WHIP"],
        ["inningsPitched","IP"],["strikeOuts","SO"],["baseOnBalls","BB"],["hits","H"],["homeRuns","HR"]
      ];
    }
    if (group === "fielding"){
      return [
        ["games","G"],["innings","Inn"],["fielding","Fld%"],["assists","A"],["putOuts","PO"],["errors","E"],["doublePlays","DP"]
      ];
    }
    if (group === "baserunning"){
      return [
        ["stolenBases","SB"],["caughtStealing","CS"],["stolenBasePercentage","SB%"],["runs","R"]
      ];
    }
    // batting default
    return [
      ["gamesPlayed","G"],["plateAppearances","PA"],["avg","AVG"],["obp","OBP"],["slg","SLG"],["ops","OPS"],
      ["homeRuns","HR"],["rbi","RBI"],["runs","R"],["hits","H"],["stolenBases","SB"]
    ];
  }

  function fmt(v){
    if (v === null || v === undefined || v === "") return "—";
    return String(v);
  }

  // local player-name sort (only for current page)
  function sortTableByPlayerName(order){
    const tbody = el("tbody");
    const rows = Array.from(tbody.querySelectorAll("tr"));
    if (!rows.length) return;

    // ignore "No results" row
    if (rows.length === 1 && (rows[0].querySelector("td")?.textContent || "").toLowerCase().includes("no results")) {
      return;
    }

    rows.sort((a,b)=>{
      const an = (a.querySelector(".pname")?.textContent || "").toLowerCase();
      const bn = (b.querySelector(".pname")?.textContent || "").toLowerCase();
      if (an < bn) return order === "asc" ? -1 : 1;
      if (an > bn) return order === "asc" ? 1 : -1;
      return 0;
    });

    tbody.innerHTML = "";
    rows.forEach(r => tbody.appendChild(r));
  }

  function buildThead(group){
    const cols = columnsFor(group);

    const curSort = el("sort").value;
    const curOrder = el("toggleOrder").dataset.order || "desc";

    const arrow = (isActive) => {
      if (!isActive) return "";
      return (curOrder === "asc") ? " ▲" : " ▼";
    };

    const thStat = (label, statKey) => {
      const isActive = statKey && curSort === statKey;
      return `<th class="num sortable" data-stat="${statKey}">${label}${arrow(isActive)}</th>`;
    };

    // Rank + Player are "special" sorts:
    // - Rank resets to group defaults and reloads
    // - Player sorts locally A/Z for current page
    const playerArrow = arrow(curSort === "__player");
    const rankArrow = arrow(curSort === "__rank");

    const headerHtml = `
      <tr>
        <th class="num sortable" data-stat="__rank" style="width:46px;">#${rankArrow}</th>
        <th class="sortable" data-stat="__player" style="width:320px;">Player${playerArrow}</th>
        ${cols.map(c => thStat(c[1], c[0])).join("")}
      </tr>
    `;
    el("thead").innerHTML = headerHtml;

    // attach click handlers
    el("thead").querySelectorAll("th.sortable").forEach(node => {
      node.style.cursor = "pointer";
      node.addEventListener("click", () => {
        const stat = node.getAttribute("data-stat") || "";

        // Rank: reset to group default sort + desc + reload
        if (stat === "__rank") {
          fillSortOptions(el("group").value);
          el("toggleOrder").dataset.order = "desc";
          el("toggleOrder").textContent = "DESC";
          load(1);
          return;
        }

        // Player: local sort A/Z on current page
        if (stat === "__player") {
          const cur = el("toggleOrder").dataset.order || "desc";
          const next = (cur === "desc") ? "asc" : "desc";
          el("toggleOrder").dataset.order = next;
          el("toggleOrder").textContent = next.toUpperCase();

          // mark as player sort so arrow shows on Player column
          el("sort").value = el("sort").value; // keep API sort unchanged
          // We store a lightweight flag by setting sort to "__player" ONLY in UI
          // but the API call uses el("sort").value, so we don't change it.
          // Instead: just rebuild head with player arrow by temporarily tracking:
          // We'll set a data attribute.
          el("thead").dataset.playerSort = next;

          sortTableByPlayerName(next);
          // rebuild header with arrow indicator by pretending player sort active
          // (we'll do this by setting a hidden "active sort" concept)
          // simplest: override local rendering by re-calling buildThead after setting a marker
          // We emulate active sort by storing a global:
          activeSpecialSort = "__player";
          buildThead(el("group").value);
          return;
        }

        // Stat columns: set sort + toggle order if already active
        const cur = el("sort").value;
        if (stat && cur === stat) {
          const o = el("toggleOrder").dataset.order || "desc";
          const next = (o === "desc") ? "asc" : "desc";
          el("toggleOrder").dataset.order = next;
          el("toggleOrder").textContent = next.toUpperCase();
        } else {
          el("sort").value = stat;
          el("toggleOrder").dataset.order = "desc";
          el("toggleOrder").textContent = "DESC";
        }

        activeSpecialSort = ""; // leaving player sort
        load(1);
      });
    });
  }

  // Tracks whether the UI is showing a "special" sort arrow (player/rank)
  // without sending it to the backend.
  let activeSpecialSort = "";

  async function load(page){
    page = page || 1;
    const group = el("group").value;

    // If we are currently in player-local sort mode, still fetch by API sort,
    // then apply local sort after rendering.
    const localPlayerOrder = (activeSpecialSort === "__player") ? (el("toggleOrder").dataset.order || "desc") : null;

    // Ensure sort dropdown has a valid value
    if (!el("sort").value) fillSortOptions(group);

    buildThead(group);

    const qs = queryParams(page);
    const url = `/stats_json?${qs}`;

    el("tbody").innerHTML = `<tr><td class="muted">Loading…</td></tr>`;

    const res = await fetch(url);
    const data = await res.json();

    renderRows(group, data);

    // Apply local sort if needed
    if (localPlayerOrder) {
      sortTableByPlayerName(localPlayerOrder);
      // rebuild thead so Player arrow shows
      buildThead(group);
    }

    el("range").textContent = data.rangeLabel || "—";
    el("pageLabel").textContent = `Page ${data.page || page}`;
    buildPageButtons(data.page || page);

    // prev/next handlers
    el("prev").onclick = () => load(Math.max(1, (data.page || page) - 1));
    el("next").onclick = () => load((data.page || page) + 1);
  }

  function renderRows(group, data){
    const cols = columnsFor(group);
    const rows = (data.rows || []);
    if (!rows.length){
      el("tbody").innerHTML = `<tr><td colspan="${2 + cols.length}" class="muted">No results.</td></tr>`;
      return;
    }

    const offset = data.offset || 0;
    const html = rows.map((r, idx)=>{
      const rank = offset + idx + 1;
      const pid = r.playerId;
      const name = r.name || "—";
      const headshot = r.headshot || "";
      const teamLogo = r.teamLogo || "";
      const stat = r.stat || {};

      return `
        <tr>
          <td class="num">${rank}</td>
          <td>
            <div class="player-chip">
              ${headshot ? `<img class="mini-headshot" src="${headshot}" alt="">` : ``}
              ${teamLogo ? `<img class="mini-teamlogo" src="${teamLogo}" alt="">` : ``}
              <a class="pname teamlink" href="${pid ? `/player/${pid}` : '#'}">${name}</a>
            </div>
          </td>
          ${cols.map(([k,label])=>`<td class="num">${fmt(stat[k])}</td>`).join("")}
        </tr>
      `;
    }).join("");

    el("tbody").innerHTML = html;
  }

  function buildPageButtons(currentPage){
    const container = el("pageButtons");
    container.innerHTML = "";
    const start = Math.max(1, currentPage - 3);
    const end = start + 6;

    for (let p = start; p <= end; p++){
      const b = document.createElement("button");
      b.className = "btn";
      const lo = (p - 1) * 50 + 1;
      const hi = p * 50;
      b.textContent = `${lo}-${hi}`;
      if (p === currentPage) {
        b.style.borderColor = "#0b0e13";
      }
      b.addEventListener("click", () => load(p));
      container.appendChild(b);
    }
  }

  // Order toggle button (manual)
  el("toggleOrder").addEventListener("click", () => {
    const cur = el("toggleOrder").dataset.order || "desc";
    const next = (cur === "desc") ? "asc" : "desc";
    el("toggleOrder").dataset.order = next;
    el("toggleOrder").textContent = next.toUpperCase();
  });

  // Apply button
  el("apply").addEventListener("click", () => {
    activeSpecialSort = "";
    load(1);
  });

  // Group change updates sort options + reload (and resets special sort)
  el("group").addEventListener("change", () => {
    activeSpecialSort = "";
    fillSortOptions(el("group").value);
    el("toggleOrder").dataset.order = "desc";
    el("toggleOrder").textContent = "DESC";
    load(1);
  });

  // init
  fillSortOptions(el("group").value);
  buildThead(el("group").value);
  load(1);
})();
</script>

{% endblock %}
